# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
import base64
import hashlib
import json
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import OrderNotFound
from ccxt.base.errors import DDoSProtection
from ccxt.base.errors import ExchangeNotAvailable


class blockbid (Exchange):

    def describe(self):
        return self.deep_extend(super(blockbid, self).describe(), {
            'id': 'blockbid',
            'name': 'Blockbid',
            'countries': ['AU'],
            'rateLimit': 1000,
            'has': {
                'CORS': False,
                'cancelOrders': True,
                'fetchDepositAddress': False,
                'fetchL2OrderBook': False,  # self probably needs to be implemented
                'fetchDeposits': True,
                'fetchMyTrades': True,
                'fetchOpenOrders': True,
                'fetchOHLCV': True,
                'fetchOrder': True,
                'fetchTicker': True,
                'fetchTickers': True,
                'fetchWithdrawals': True,
                'withdraw': True,
            },
            'timeframes': {
                '1m': 1,
                '5m': 5,
                '15m': 15,
                '30m': 30,
                '1h': 60,
                '2h': 120,
                '4h': 240,
                '6h': 360,
                '12h': 720,
                '1d': 1440,
                '3d': 4280,
                '1w': 10080,
            },
            'urls': {
                'api': 'https://api.blockbid.io',
                'www': 'https://platform.blockbid.io',
                'doc': 'https://docs.blockbid.io',
                'logo': 'https://platform.blockbid.io/static/logo.svg',
            },
            'requiredCredentials': {
                'apiKey': True,
                'secret': True,
                'uid': False,
                'login': False,
                'password': False,
                'twofa': False,
                'privateKey': False,
                'walletAddress': False,
            },
            'api': {
                'public': {
                    'get': [
                        'markets',
                        'tickers',
                        'ohlc',
                        'orderbook',
                        'trades',
                    ],
                },
                'private': {
                    'get': [
                        'identity',
                        'balances',
                        'balances/{currency}',
                        'addresses',
                        'deposits/crypto',
                        'trades/my',
                        'orders',
                        'orders/{id}',
                        'withdraws/fiat',
                        'withdraws/crypto',
                    ],
                    'post': [
                        'orders',
                        'withdraws/fiat',
                        'withdraw/crypto',
                    ],
                    'delete': [
                        'orders',
                        'orders/{id}',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'tierBased': False,
                    'percentage': True,
                    'maker': 0.1,
                    'taker': 0.1,
                },
            },
            'precision': {
                'amount': 8,
                'price': 8,
            },
            'supportedFiat': [
                'AUD',
                'USD',
                'EUR',
                'JPY',
            ],
            'exceptions': {
                'exact': {
                    'server_error': ExchangeNotAvailable,
                    'internal_error': ExchangeError,
                    'view_order_failed': OrderNotFound,
                    'order_failed': InvalidOrder,
                    'rate_limited': DDoSProtection,
                },
            },
        })

    def fetch_markets(self):
        response = self.publicGetMarkets()
        #
        #     [
        #         {"id":"btcaud","name":"BTC/AUD"},
        #         {"id":"ethaud","name":"ETH/AUD"},
        #         ...
        #     ]
        #
        result = []
        for i in range(0, len(response)):
            market = response[i]
            id = market['id']
            name = market['name']
            pairArray = name.split('/')
            baseId = pairArray[0]
            quoteId = pairArray[1]
            base = self.common_currency_code(baseId)
            quote = self.common_currency_code(quoteId)
            symbol = base + '/' + quote
            precision = {
                'amount': 8,
                'price': None,
            }
            active = self.safe_value(market, 'is_active', True)
            result.append({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId.lower(),
                'quoteId': quoteId.lower(),
                'active': active,
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': self.safe_float(market, 'base_min_size'),
                        'max': self.safe_float(market, 'base_max_size'),
                    },
                    'price': {
                        'min': None,
                        'max': None,
                    },
                    'cost': {
                        'min': None,
                        'max': None,
                    },
                },
                'info': market,
            })
        return result

    def parse_ticker(self, ticker, market=None):
        #
        #     {"timestamp":"2018-11-08T23:32:28.000Z","market":"btcaud","last":8821.15382691}
        #
        symbol = None
        if market is None:
            marketId = self.safe_string(ticker, 'market')
            if marketId in self.markets_by_id:
                market = self.markets_by_id[marketId]
            else:
                pairArray = marketId.split('-')
                baseId = pairArray[0]
                quoteId = pairArray[1]
                base = self.common_currency_code(baseId)
                quote = self.common_currency_code(quoteId)
                symbol = base + '/' + quote
        if market is not None:
            symbol = market['symbol']
        timestamp = self.parse8601(self.safe_string(ticker, 'timestamp'))
        last = self.safe_float(ticker, 'last')
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': None,
            'low': None,
            'bid': None,
            'bidVolume': None,
            'ask': None,
            'askVolume': None,
            'vwap': None,
            'open': None,
            'close': last,
            'last': last,
            'previousClose': None,
            'change': None,
            'percentage': None,
            'average': None,
            'baseVolume': None,
            'quoteVolume': None,
            'info': ticker,
        }

    def fetch_ticker(self, symbol=None, params={}):
        self.load_markets()
        tickers = self.fetch_tickers(None, params)
        ticker = self.safe_value(tickers, symbol)
        if ticker is None:
            raise ExchangeError(self.id + ' fetchTicker could not fetch ticker for market symbol ' + symbol)
        return ticker

    def fetch_tickers(self, symbols=None, params={}):
        self.load_markets()
        response = self.publicGetTickers(params)
        #
        #     [
        #         {"timestamp":"2018-11-08T23:32:28.000Z","market":"btcaud","last":8821.15382691},
        #         {"timestamp":"2018-11-08T23:32:28.000Z","market":"ethaud","last":291.45242072},
        #         ...
        #     ]
        #
        result = []
        for i in range(0, len(response)):
            result.append(self.parse_ticker(response[i]))
        return self.index_by(result, 'symbol')

    def fetch_order_book(self, symbol, limit=None, params={}):
        self.load_markets()
        request = {
            'market': self.market_id(symbol),
        }
        if limit is not None:
            request['asks_limit'] = limit
            request['bids_limit'] = limit
        response = self.publicGetOrderbook(self.extend(request, params))
        return self.parse_order_book(response, None, 'bids', 'asks', 'price', 'volume')

    def parse_trade(self, trade, market=None):
        symbol = None
        if market is not None:
            symbol = market['symbol']
        timestamp = self.parse8601(self.safe_string(trade, 'createdAt'))
        price = self.safe_float(trade, 'price')
        amount = self.safe_float(trade, 'volume')
        cost = None
        if price is not None:
            if amount is not None:
                cost = price * amount
        side = self.safe_string(trade, 'side')
        id = self.safe_string(trade, 'id')
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'id': id,
            'order': None,
            'type': None,
            'side': side,
            'price': price,
            'amount': amount,
            'cost': cost,
            'fee': None,
        }

    def fetch_trades(self, symbol, since=None, limit=50, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'market': market['id'],
            'limit': limit,
        }
        response = self.publicGetTrades(self.extend(request, params))
        return self.parse_trades(response, market, since, limit)

    def parse_ohlcv(self, ohlcv, market=None, timeframe='1m', since=None, limit=None):
        return [
            self.parse8601(self.safe_string(ohlcv, 'timestamp')),
            self.safe_float(ohlcv, 'open'),
            self.safe_float(ohlcv, 'high'),
            self.safe_float(ohlcv, 'low'),
            self.safe_float(ohlcv, 'close'),
            self.safe_float(ohlcv, 'volume'),
        ]

    def fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'market': market['id'],
            'period': self.timeframes[timeframe],
        }
        if since is not None:
            request['timestamp'] = since
        response = self.publicGetOhlc(self.extend(request, params))
        return self.parse_ohlcvs(response, market, timeframe, since, limit)

    def fetch_balance(self, params={}):
        self.load_markets()
        response = self.privateGetBalances(params)
        result = {'info': response}
        for i in range(0, len(response)):
            balance = response[i]
            currency = balance['currency'].upper()
            if currency in self.currencies_by_id:
                currency = self.currencies_by_id[currency]['code']
            account = {
                'free': balance['available'],
                'used': balance['locked'],
                'total': balance['total'],
            }
            result[currency] = account
        return self.parse_balance(result)

    def parse_order_status(self, status):
        statuses = {
            'filled': 'closed',
            'rejected': 'closed',
            'partially_filled': 'open',
            'pending_cancellation': 'open',
            'pending_modification': 'open',
            'open': 'open',
            'new': 'open',
            'queued': 'open',
            'cancelled': 'canceled',
            'triggered': 'triggered',
        }
        return self.safe_string(statuses, status, status)

    def parse_order(self, order, market=None):
        id = self.safe_string(order, 'id')
        symbol = None
        marketId = self.safe_string(order, 'market')
        market = self.safe_value(self.markets_by_id, marketId, market)
        if market is not None:
            symbol = market['symbol']
        price = self.safe_float(order, 'price')
        average = self.safe_float(order, 'averagePrice')
        amount = self.safe_float(order, 'volume')
        filled = self.safe_float(order, 'executedVolume')
        remaining = self.safe_float(order, 'remainingVolume')
        cost = None
        if average is not None:
            if filled is not None:
                cost = average * filled
            else:
                cost = average * amount
        status = self.parse_order_status(self.safe_string(order, 'state'))
        side = self.safe_string(order, 'side')
        if side == 'bid':
            side = 'buy'
        elif side == 'ask':
            side = 'sell'
        type = self.safe_string(order, 'orderType')
        timestamp = self.parse8601(self.safe_string(order, 'createdAt'))
        trades = None  # not to be confused with trades count
        return {
            'id': id,
            'datetime': self.iso8601(timestamp),
            'timestamp': timestamp,
            'lastTradeTimestamp': None,
            'status': status,
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'cost': cost,
            'average': average,
            'amount': amount,
            'filled': filled,
            'trades': trades,
            'remaining': remaining,
            'fee': None,
            'info': order,
        }

    def create_order(self, symbol, type, side, amount, price, params={}):
        self.load_markets()
        market = self.market(symbol)
        method = 'privatePostOrders'
        order = {
            'side': side,
            'volume': amount,
        }
        if type is not None:
            order['orderType'] = type
        if price is not None:
            order['price'] = price
        request = {
            'market': market['id'],
            'orders': [order],
        }
        response = getattr(self, method)(self.extend(request, params))
        return self.parse_order(response[0], market)

    def cancel_order(self, id, symbol=None, params={}):
        self.load_markets()
        response = self.privateDeleteOrdersId(self.extend({
            'id': id,
        }, params))
        return self.parse_order(self.extend(response, {'id': id}))

    def cancel_orders(self, side=None, params={}):
        self.load_markets()
        request = {}
        if side is not None:
            request['side'] = side
        response = self.privateDeleteOrders(self.extend(request, params))
        return self.parse_orders(response)

    def fetch_order(self, id, symbol=None, params={}):
        self.load_markets()
        request = {
            'id': id,
        }
        response = self.privateGetOrdersId(self.extend(request, params))
        return self.parse_order(response)

    def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'market': market['id'],
        }
        if limit is not None:
            request['limit'] = limit
        result = self.privateGetOrders(self.extend(request, params))
        return self.parse_orders(result, None, since, limit)

    def fetch_deposits(self, code=None, since=None, limit=None, params={}):
        self.load_markets()
        if code is None:
            raise ExchangeError(self.id + ' fetchDeposits() requires a currency code arguemnt')
        currency = self.currency(code)
        request = {
            'currency': currency['id'],
        }
        response = self.privateGetDepositsCrypto(self.extend(request, params))
        deposits = []
        for i in range(0, len(response)):
            response[i].type = 'deposit'
            deposits.append(response[i])
        return self.parseTransactions(deposits, currency)

    def parse_transaction_status(self, status):
        statuses = {
            'processing': 'pending',
            'rejected': 'failed',
            'accepted': 'ok',
            'succeed': 'ok',
        }
        return statuses[status] if (status in list(statuses.keys())) else status

    def fetch_my_trades(self, symbol=None, since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'market': market['id'],
        }
        if limit is not None:
            request['limit'] = limit
        response = self.privateGetTradesMy(self.extend(request, params))
        return self.parse_trades(response, market, since, limit)

    def fetch_withdrawals(self, code=None, since=None, limit=None, params={}):
        self.load_markets()
        currency = self.currency(code)
        request = {
            'currency': currency['id'],
        }
        if limit is not None:
            request['limit'] = limit
        currencyCode = currency['code']
        isFiat = False
        for i in range(0, len(self.supportedFiat)):
            if currencyCode == self.supportedFiat[i]:
                isFiat = True
        method = 'privateGetWithdrawsFiat' if isFiat else 'privateGetWithdrawsCrypto'
        response = getattr(self, method)(self.extend(request, params))
        withdrawals = []
        for i in range(0, len(response)):
            response[i].type = 'withdrawal'
            withdrawals.append(response[i])
        return self.parseTransactions(withdrawals, currency, since, limit)

    def parse_transaction_statuses(self, status):
        statuses = {
        }
        return self.safe_string(statuses, status, status)

    def parse_transaction(self, transaction, currency=None):
        id = self.safe_string(transaction, 'id')
        txid = self.safe_string(transaction, 'txid')
        timestamp = self.parse8601(self.safe_string(transaction, 'createdAt'))
        code = None
        currencyId = self.safe_string(transaction, 'currency')
        address = self.safe_string(transaction, 'address')
        currency = self.safe_value(self.currencies_by_id, currencyId)
        if currency is not None:
            code = currency['code']
        else:
            code = self.common_currency_code(currencyId)
        amount = self.safe_float(transaction, 'amount')
        status = self.parse_transaction_status(self.safe_string(transaction, 'state'))
        updated = self.safe_string(transaction, 'createdAt')
        type = self.safe_string(transaction, 'type')
        fee = {
            'cost': self.safe_float(transaction, 'fee'),
            'currency': code,
            'rate': None,
        }
        return {
            'info': transaction,
            'id': id,
            'txid': txid,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'address': address,
            'tag': None,  # or is it defined?
            'type': type,  # direction of the transaction,('deposit' | 'withdraw')
            'amount': amount,
            'currency': code,
            'status': status,
            'updated': updated,
            'fee': fee,
        }

    def sign(self, path, api='public', method='GET', params=None):
        url = self.urls['api'] + '/' + self.implode_params(path, params)
        body = None
        query = None
        if method == 'GET':
            query = self.omit(params, self.extract_params(path))
            query = self.urlencode(query)
            if len(query):
                url += '?' + query
        elif method != 'DELETE':
            body = params
        headers = {'Content-Type': 'application/json'}
        if api == 'private':
            self.check_required_credentials()
            nonce = self.nonce()
            nonce = str(nonce)
            encodedApiKey = self.encode(self.apiKey)
            encodedNonce = self.encode(nonce)
            rawSignature = base64.b64encode(encodedApiKey) + base64.b64encode(encodedNonce)
            stringifyedPayload = ''
            if body and body > 0:
                stringifyedPayload = self.encode(json.dumps(body))
            body = json.dumps(body)
            rawSignature = rawSignature + base64.b64encode(stringifyedPayload)
            encodedSecret = self.encode(self.secret)
            signature = self.hmac(rawSignature, encodedSecret, hashlib.sha384, 'base64')
            headers['X-Blockbid-Signature'] = signature
            headers['X-Blockbid-Nonce'] = nonce
            headers['X-Blockbid-Api-Key'] = self.apiKey
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_errors(self, code, reason, url, method, headers, body):
        if not self.is_json_encoded_object(body):
            return  # fallback to default error handler
        response = json.loads(body)
        error = self.safe_value(response, 'error')
        if error is not None:
            feedback = self.id + ' ' + body
            code = self.safe_string(error, 'name')
            exact = self.exceptions['exact']
            if code in exact:
                raise exact[code](feedback)
            raise ExchangeError(feedback)  # unknown message

    def nonce(self):
        return self.milliseconds()
