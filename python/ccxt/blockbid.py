# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
import base64
import hashlib
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import PermissionDenied


class blockbid (Exchange):

    def describe(self):
        return self.deep_extend(super(blockbid, self).describe(), {
            'id': 'blockbid',
            'name': 'Blockbid',
            'countries': ['AUS'],
            'rateLimit': 1000,
            'has': {
                'CORS': False,
                'cancelOrders': True,
                'fetchDepositAddress': True,
                'fetchL2OrderBook': False,  # self probably needs to be implemented
                'fetchDeposits': True,
                'fetchMyTrades': True,
                'fetchOpenOrders': True,
                'fetchOHLCV': True,
                'fetchOrder': True,
                'fetchTicker': False,
                'fetchTickers': True,
                'fetchWithdrawals': True,
                'withdraw': True,
            },
            'timeframes': {
                '1m': 1,
                '5m': 5,
                '15m': 15,
                '30m': 30,
                '1h': 60,
                '2h': 120,
                '4h': 240,
                '6h': 360,
                '12h': 720,
                '1d': 1440,
                '3d': 4280,
                '1w': 10080,
            },
            'urls': {
                'api': 'https://api.dev.blockbid.io',
                'www': 'https://devblockbid.io',
                'doc': 'https://doc.devblockbid.io',
            },
            'api': {
                'public': {
                    'get': ['markets', 'tickers', 'ohlc', 'orderbook', 'trades']
                },
                'private': {
                    'get': [
                        'identity',
                        'balances',
                        'balances/{currency}',
                        'addresses',
                        'deposits',
                        'deposits/{id}',
                        'trades/my',
                        'orders',
                        'orders/{id}',
                        'withdraws/fiat',
                        'withdraws/crypto',
                    ],
                    'post': [
                        'orders',
                        'withdraws/fiat',
                        'withdraw/crypto',
                    ],
                    'delete': [
                        'orders',
                        'orders/{id}',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'tierBased': False,
                    'percentage': True,
                    'maker': 0.1,
                    'taker': 0.1,
                },
            },
            'precision': {
                'amount': 8,
                'price': 8,
            },
            'supportedFiat': [
                'AUD',
                'USD',
                'EUR',
                'JPY',
            ],
        })

    def fetch_markets(self):
        markets = self.publicGetMarkets()
        err = self.handle_error(markets)
        if err:
            raise ExchangeError(self.id + ' has thrown an error: ' + err)
        result = []
        for i in range(0, len(markets)):
            market = markets[i]
            id = market['id']
            name = market['name']
            [baseId, quoteId] = name.split('/')
            base = self.common_currency_code(baseId)
            quote = self.common_currency_code(quoteId)
            symbol = base + '/' + quote
            precision = None
            active = self.safe_value(market, 'is_active', True)
            result.append({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId.lower(),
                'quoteId': quoteId.lower(),
                'active': active,
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': self.safe_float(market, 'base_min_size'),
                        'max': self.safe_float(market, 'base_max_size'),
                    },
                    'price': {
                        'min': None,
                        'max': None,
                    },
                    'cost': {
                        'min': None,
                        'max': None,
                    },
                },
                'info': market,
            })
        return result

    def parse_ticker(self, ticker, market=None):
        symbol = None
        if market is None:
            marketId = self.safe_string(ticker, 'market')
            if marketId in self.markets_by_id:
                market = self.markets_by_id[marketId]
            else:
                [baseId, quoteId] = marketId.split('-')
                base = self.common_currency_code(baseId)
                quote = self.common_currency_code(quoteId)
                symbol = base + '/' + quote
        if market is not None:
            symbol = market['symbol']
        datetime = self.safe_string(ticker, 'timestamp')
        timestamp = self.parse8601(datetime)
        last = self.safe_float(ticker, 'last')
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': datetime,
            'high': self.safe_float(ticker, '24h_high'),
            'low': self.safe_float(ticker, '24h_low'),
            'bid': self.safe_float(ticker, 'highest_bid'),
            'bidVolume': None,
            'ask': self.safe_float(ticker, 'lowest_ask'),
            'askVolume': None,
            'vwap': None,
            'open': None,
            'close': last,
            'last': last,
            'previousClose': None,
            'change': self.safe_float(ticker, 'percentChanged24hr'),
            'percentage': None,
            'average': None,
            'baseVolume': self.safe_float(ticker, '24h_volume'),
            'quoteVolume': self.safe_float(ticker, 'quote_volume'),
            'info': ticker}

    def fetch_ticker(self, symbol=None, params={}):
        self.load_markets()
        tickers = self.publicGetTickers(params)
        err = self.handle_error(tickers)
        if err:
            raise ExchangeError(self.id + ' has thrown an error: ' + err)
        marketId = self.market_id(symbol)
        for i in range(0, len(tickers)):
            ticker = tickers[i]
            if ticker.market == marketId:
                return self.parse_ticker(ticker)

    def fetch_tickers(self, symbols=None, params={}):
        self.load_markets()
        tickers = self.publicGetTickers(params)
        result = []
        for i in range(0, len(tickers)):
            result.append(self.parse_ticker(tickers[i]))
        return self.index_by(result, 'symbol')

    def fetch_order_book(self, symbol, limit=None, params={}):
        self.load_markets()
        request = {
            'market': self.market_id(symbol)
        }
        if limit is not None:
            request['asks_limit'] = limit
            request['bids_limit'] = limit
        response = self.publicGetOrderbook(self.extend(request, params))
        err = self.handle_error(response)
        if err:
            raise ExchangeError(self.id + ' has thrown an error: ' + err)
        preParseBook = {}
        arrBids = []
        arrAsks = []
        for i in range(0, len(response.bids)):
            arrBids.append([response.bids[i].price, response.bids[i].volume, []])
        for i in range(0, len(response.asks)):
            arrAsks.append([response.asks[i].price, response.asks[i].volume, []])
        preParseBook['bids'] = arrBids
        preParseBook['asks'] = arrAsks
        return self.parse_order_book(preParseBook, None, 'bids', 'asks', 0, 1)

    def parse_trade(self, trade, market=None):
        symbol = None
        if market:
            symbol = market['symbol']
        datetime = trade['createdAt']
        timestamp = self.parse8601(datetime)
        price = self.safe_float(trade, 'price')
        amount = self.safe_float(trade, 'volume')
        cost = price * amount
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': datetime,
            'symbol': symbol,
            'id': trade['id'],
            'order': None,
            'type': None,
            'side': trade['side'],
            'price': price,
            'amount': amount,
            'cost': cost,
            'fee': None}

    def fetch_trades(self, symbol, since=None, limit=50, params={}):
        self.load_markets()
        market = self.market(symbol)
        response = self.publicGetTrades(
            self.extend({
                'market': market['id'],
                'limit': limit,
            }, params)
        )
        err = self.handle_error(response)
        if err:
            raise ExchangeError(self.id + ' has thrown an error: ' + err)
        return self.parse_trades(response, market, since, limit)

    def parse_ohlcv(self, ohlcv, market=None, timeframe='5m', since=None, limit=None):
        datetime = self.parse8601(ohlcv['timestamp'])
        return [
            datetime,
            float(ohlcv['open']),
            float(ohlcv['high']),
            float(ohlcv['low']),
            float(ohlcv['close']),
            float(ohlcv['volume']),
        ]

    def fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'market': market['id'],
            'period': self.timeframes[timeframe],
        }
        if since is not None:
            request['timestamp'] = since
        response = self.publicGetOhlc(self.extend(request, params))
        err = self.handle_error(response)
        if err:
            raise ExchangeError(self.id + ' has thrown an error: ' + err)
        return self.parse_ohlcvs(response, market, timeframe, since, limit)

    def fetch_balance(self, params={}):
        self.load_markets()
        if not self.apiKey or not self.secret:
            raise PermissionDenied(self.id + ' fetchBalance() requires you to have a valid api key and secret.')
        response = self.privateGetBalances(params)
        err = self.handle_error(response)
        if err:
            raise ExchangeError(self.id + ' has thrown an error: ' + err)
        result = {'info': response}
        for i in range(0, len(response)):
            balance = response[i]
            currency = balance['currency']
            if currency in self.currencies_by_id:
                currency = self.currencies_by_id[currency]['code']
            account = {
                'free': balance['available'],
                'used': balance['locked'],
                'total': balance['total'],
            }
            result[currency] = account
        return self.parse_balance(result)

    def parse_order_status(self, status):
        statuses = {
            'filled': 'closed',
            'rejected': 'closed',
            'partially_filled': 'open',
            'pending_cancellation': 'open',
            'pending_modification': 'open',
            'open': 'open',
            'new': 'open',
            'queued': 'open',
            'cancelled': 'canceled',
            'triggered': 'triggered',
        }
        if status in statuses:
            return statuses[status]
        return status

    def parse_order(self, order, market=None):
        symbol = None
        if market is None:
            marketId = self.safe_string_2(order, 'market')
            market = self.safe_value(self.markets_by_id, marketId)
        if market is not None:
            symbol = market['symbol']
        datetime = self.safe_string(order, 'createdAt')
        price = self.safe_float(order, 'price')
        average = self.safe_float(order, 'averagePrice')
        amount = self.safe_float(order, 'volume')
        filled = self.safe_float(order, 'executedVolume')
        remaining = self.safe_float(order, 'remainingVolume')
        cost = None
        if filled is not None and average is not None:
            cost = average * filled
        elif average is not None:
            cost = average * amount
        status = self.parse_order_status(self.safe_string(order, 'state'))
        side = self.safe_string(order, 'side')
        if side == 'bid':
            side = 'buy'
        elif side == 'ask':
            side = 'sell'
        timestamp = self.parse8601(datetime)
        return {
            'id': self.safe_string(order, 'id'),
            'datetime': datetime,
            'timestamp': timestamp,
            'lastTradeTimestamp': None,
            'status': status,
            'symbol': symbol,
            'type': self.safe_string(order, 'orderType'),
            'side': side,
            'price': price,
            'cost': cost,
            'average': average,
            'amount': amount,
            'filled': filled,
            'trades': self.safe_string(order, 'tradesCount'),
            'remaining': remaining,
            'fee': None,
            'info': order}

    def create_order(self, symbol, type, side, amount, price=None, params={}):
        if not self.apiKey or not self.secret:
            raise PermissionDenied(self.id + ' createOrder() requires you to have a valid api key and secret.')
        self.load_markets()
        market = self.market(symbol)
        request = {
            'market': market['id'],
            'orders': [
                {
                    'side': side,
                    'volume': amount,
                    'ord_type': type,
                },
            ],
        }
        if type != 'market':
            request['orders'][0]['price'] = price
        response = self.privatePostOrders(self.extend(request, params))
        err = self.handle_error(response)
        if err:
            raise ExchangeError(self.id + ' has thrown an error: ' + err)
        order = self.parse_order(response[0], market)
        id = order['id']
        self.orders[id] = order
        return order

    def cancel_order(self, id, params={}):
        if not self.apiKey or not self.secret:
            raise PermissionDenied(self.id + ' cancelOrder() requires you to have a valid api key and secret.')
        response = self.privateDeleteOrdersId(
            self.extend({
                'id': id,
            }, params)
        )
        if response.error or response.message:
            raise PermissionDenied(self.id + ' cancelOrder() requires a valid api key')
        return self.parse_order(
            self.extend(response, {'id': id})
        )

    def cancel_orders(self, side, params={}):
        if not self.apiKey or not self.secret:
            raise PermissionDenied(self.id + ' cancelOrders() requires you to have a valid api key and secret.')
        response = self.privateDeleteOrders(
            self.extend({'side': side}, params)
        )
        err = self.handle_error(response)
        if err:
            raise ExchangeError(self.id + ' has thrown an error: ' + err)
        return self.parse_orders(response)

    def fetch_order(self, id, symbol=None, params={}):
        if not self.apiKey or not self.secret:
            raise PermissionDenied(self.id + ' fetchOrder() requires you to have a valid api key and secret.')
        self.load_markets()
        response = self.privateGetOrdersId(
            self.extend({'id': str(id)}, params)
        )
        err = self.handle_error(response)
        if err:
            raise ExchangeError(self.id + ' has thrown an error: ' + err)
        return self.parse_order(response)

    def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        if not self.apiKey or not self.secret:
            raise PermissionDenied(self.id + ' fetchOpenOrders() requires you to have a valid api key and secret.')
        self.load_markets()
        market = self.market(symbol)
        request = {
            'market': market['id'],
            'limit': limit,
        }
        result = self.privateGetOrders(self.extend(request, params))
        err = self.handle_error(result)
        if err:
            raise ExchangeError(self.id + ' has thrown an error: ' + err)
        orders = self.parse_orders(result, None, since, limit)
        return orders

    def fetch_my_trades(self, symbol=None, since=None, limit=None, params={}):
        if not self.apiKey or not self.secret:
            raise PermissionDenied(self.id + ' fetchMyTrades() requires you to have a valid api key and secret.')
        self.load_markets()
        market = self.market(symbol)
        request = {
            'market': market['id'],
            'limit': limit,
        }
        response = self.privateGetTradesMy(self.extend(request, params))
        err = self.handle_error(response)
        if err:
            raise ExchangeError(self.id + ' has thrown an error: ' + err)
        return self.parse_trades(response, market, since, limit)

    def fetch_withdrawals(self, code=None, since=None, limit=None, params={}):
        if not self.apiKey or not self.secret:
            raise PermissionDenied(self.id + ' fetchWithdrawals() requires you to have a valid api key and secret.')
        self.load_markets()
        if code is None:
            raise ExchangeError(self.id + ' fetchWithdrawals() requires a currency code argument')
        currency = self.currency(code)
        request = {
            'currency': currency['id'],
            'limit': limit,
        }
        currencyCode = currency['code']
        if self.supportedFiat.find(currencyCode) != -1:
            response = self.privateGetWithdrawsFiat(
                self.extend(request, params)
            )
            err = self.handle_error(response)
            if err:
                raise ExchangeError(self.id + ' has thrown an error: ' + err)
            return self.parseTransactions(response, currency)
        else:
            response = self.privateGetWithdrawsCrypto(
                self.extend(request, params)
            )
            err = self.handle_error(response)
            if err:
                raise ExchangeError(self.id + ' has thrown an error: ' + err)
            return self.parseTransactions(response, currency)

    def parse_transaction_status(self, status):
        statuses = {
            'tx_pending_two_factor_auth': 'pending',
            'tx_pending_email_auth': 'pending',
            'tx_pending_approval': 'pending',
            'tx_approved': 'pending',
            'tx_processing': 'pending',
            'tx_pending': 'pending',
            'tx_sent': 'pending',
            'tx_cancelled': 'canceled',
            'tx_timeout': 'error',
            'tx_invalid': 'error',
            'tx_rejected': 'error',
            'tx_confirmed': 'ok',
        }
        return status in statuses[status] if statuses else status.lower()

    def parse_transaction(self, transaction, currency=None):
        datetime = self.safe_string(transaction, 'timeCreated')
        timestamp = self.parse8601(datetime)
        code = None
        if currency is None:
            currencyId = self.safe_string(transaction, 'currency')
            if currencyId in self.currencies_by_id:
                currency = self.currencies_by_id[currencyId]
            code = self.common_currency_code(currencyId)
        if currency is not None:
            code = currency['code']
        return {
            'info': transaction,
            'id': self.safe_string(transaction, 'withdrawID'),
            'txid': self.safe_string(transaction, 'txid'),
            'timestamp': timestamp,
            'datetime': datetime,
            'address': self.safe_string(transaction, 'address'),  # or is it defined?
            'type': None,  # direction of the transaction,('deposit' | 'withdraw')
            'amount': self.safe_float(transaction, 'amount'),
            'currency': code,
            'status': self.parse_transaction_status(transaction['state']),
            'updated': self.safe_string(transaction, 'timeUpdated'),
            'fee': {
                'cost': self.safe_float(transaction, 'fee'),
                'rate': None,
            },
        }

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        url = self.urls['api'] + '/' + self.implode_params(path, params)
        query = self.omit(params, self.extract_params(path))
        headers = {}
        if api == 'private':
            nonce = self.safe_string(self.nonce())
            rawSignature = base64.b64encode(self.apiKey) + base64.b64encode(nonce)
            self.check_required_credentials()
            signature = self.hmac(rawSignature, self.secret, hashlib.sha384, 'base64')
            headers['X-Blockbid-Signature'] = signature
            headers['X-Blockbid-Nonce'] = nonce
            headers['X-Blockbid-Api-Key'] = self.apiKey
        if method == 'GET':
            query = self.urlencode(query)
            if len(query):
                url += '?' + query
        else:
            headers['Content-type'] = 'application/json charset=UTF-8'
            body = self.json(query)
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_error(self, response):
        if response.error:
            return response.error.message
        if response.message:
            return response.message
        return None

    def nonce(self):
        return self.milliseconds()
