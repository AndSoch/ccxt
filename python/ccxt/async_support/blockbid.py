# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.async_support.base.exchange import Exchange
import base64
import hashlib
import json
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import OrderNotFound
from ccxt.base.errors import DDoSProtection
from ccxt.base.errors import ExchangeNotAvailable


class blockbid (Exchange):

    def describe(self):
        return self.deep_extend(super(blockbid, self).describe(), {
            'id': 'blockbid',
            'name': 'Blockbid',
            'countries': ['AU'],
            'rateLimit': 1000,
            'has': {
                'CORS': False,
                'cancelOrders': True,
                'fetchDepositAddress': False,
                'fetchL2OrderBook': False,  # self probably needs to be implemented
                'fetchDeposits': True,
                'fetchMyTrades': True,
                'fetchOpenOrders': True,
                'fetchOHLCV': True,
                'fetchOrder': True,
                'fetchTicker': True,
                'fetchTickers': True,
                'fetchWithdrawals': True,
                'withdraw': True,
            },
            'timeframes': {
                '1m': 1,
                '5m': 5,
                '15m': 15,
                '30m': 30,
                '1h': 60,
                '2h': 120,
                '4h': 240,
                '6h': 360,
                '12h': 720,
                '1d': 1440,
                '3d': 4280,
                '1w': 10080,
            },
            'urls': {
                'api': 'https://api.blockbid.io',
                'www': 'https://platform.blockbid.io',
                'doc': 'https://docs.blockbid.io',
                'logo': 'https://platform.blockbid.io/static/logo.svg',
            },
            'requiredCredentials': {
                'apiKey': True,
                'secret': True,
                'uid': False,
                'login': False,
                'password': False,
                'twofa': False,
                'privateKey': False,
                'walletAddress': False,
            },
            'api': {
                'public': {
                    'get': [
                        'markets',
                        'tickers',
                        'ohlc',
                        'orderbook',
                        'trades',
                    ],
                },
                'private': {
                    'get': [
                        'identity',
                        'balances',
                        'balances/{currency}',
                        'addresses',
                        'deposits/crypto',
                        'trades/my',
                        'orders',
                        'orders/{id}',
                        'withdraws/fiat',
                        'withdraws/crypto',
                    ],
                    'post': [
                        'orders',
                        'withdraws/fiat',
                        'withdraw/crypto',
                    ],
                    'delete': [
                        'orders',
                        'orders/{id}',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'tierBased': False,
                    'percentage': True,
                    'maker': 0.1,
                    'taker': 0.1,
                },
            },
            'precision': {
                'amount': 8,
                'price': 8,
            },
            'supportedFiat': [
                'AUD',
                'USD',
                'EUR',
                'JPY',
            ],
            'exceptions': {
                'exact': {
                    'server_error': ExchangeNotAvailable,
                    'internal_error': ExchangeError,
                    'view_order_failed': OrderNotFound,
                    'order_failed': InvalidOrder,
                    'rate_limited': DDoSProtection,
                },
            },
        })

    async def fetch_markets(self, params=[]):
        response = await self.publicGetMarkets()
        #
        #     [
        #         {"id":"btcaud","name":"BTC/AUD"},
        #         {"id":"ethaud","name":"ETH/AUD"},
        #         ...
        #     ]
        #
        result = []
        for i in range(0, len(response)):
            market = response[i]
            id = market['id']
            name = market['name']
            pairArray = name.split('/')
            baseId = pairArray[0]
            quoteId = pairArray[1]
            base = self.common_currency_code(baseId)
            quote = self.common_currency_code(quoteId)
            symbol = base + '/' + quote
            precision = {
                'amount': 8,
                'price': None,
            }
            active = self.safe_value(market, 'is_active', True)
            result.append({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId.lower(),
                'quoteId': quoteId.lower(),
                'active': active,
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': self.safe_float(market, 'base_min_size'),
                        'max': self.safe_float(market, 'base_max_size'),
                    },
                    'price': {
                        'min': None,
                        'max': None,
                    },
                    'cost': {
                        'min': None,
                        'max': None,
                    },
                },
                'info': market,
            })
        return result

    def parse_ticker(self, ticker, market=None):
        #
        #     {"timestamp":"2018-11-08T23:32:28.000Z","market":"btcaud","last":8821.15382691}
        #
        symbol = None
        if market is None:
            marketId = self.safe_string(ticker, 'market')
            if marketId in self.markets_by_id:
                market = self.markets_by_id[marketId]
            else:
                pairArray = marketId.split('-')
                baseId = pairArray[0]
                quoteId = pairArray[1]
                base = self.common_currency_code(baseId)
                quote = self.common_currency_code(quoteId)
                symbol = base + '/' + quote
        if market is not None:
            symbol = market['symbol']
        timestamp = self.parse8601(self.safe_string(ticker, 'timestamp'))
        last = self.safe_float(ticker, 'last')
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': None,
            'low': None,
            'bid': None,
            'bidVolume': None,
            'ask': None,
            'askVolume': None,
            'vwap': None,
            'open': None,
            'close': last,
            'last': last,
            'previousClose': None,
            'change': None,
            'percentage': None,
            'average': None,
            'baseVolume': None,
            'quoteVolume': None,
            'info': ticker,
        }

    async def fetch_ticker(self, symbol=None, params={}):
        await self.load_markets()
        tickers = await self.fetch_tickers(None, params)
        ticker = self.safe_value(tickers, symbol)
        if ticker is None:
            raise ExchangeError(self.id + ' fetchTicker could not fetch ticker for market symbol ' + symbol)
        return ticker

    async def fetch_tickers(self, symbols=None, params={}):
        await self.load_markets()
        response = await self.publicGetTickers(params)
        #
        #     [
        #         {"timestamp":"2018-11-08T23:32:28.000Z","market":"btcaud","last":8821.15382691},
        #         {"timestamp":"2018-11-08T23:32:28.000Z","market":"ethaud","last":291.45242072},
        #         ...
        #     ]
        #
        result = []
        for i in range(0, len(response)):
            result.append(self.parse_ticker(response[i]))
        return self.index_by(result, 'symbol')

    async def fetch_order_book(self, symbol, limit=None, params={}):
        await self.load_markets()
        request = {
            'market': self.market_id(symbol),
        }
        if limit is not None:
            request['asks_limit'] = limit
            request['bids_limit'] = limit
        response = await self.publicGetOrderbook(self.extend(request, params))
        return self.parse_order_book(response, None, 'bids', 'asks', 'price', 'volume')

    def parse_trade(self, trade, market=None):
        symbol = None
        if market is not None:
            symbol = market['symbol']
        timestamp = self.parse8601(self.safe_string(trade, 'createdAt'))
        price = self.safe_float(trade, 'price')
        amount = self.safe_float(trade, 'volume')
        cost = None
        if price is not None:
            if amount is not None:
                cost = price * amount
        side = self.safe_string(trade, 'side')
        id = self.safe_string(trade, 'id')
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'id': id,
            'order': None,
            'type': None,
            'side': side,
            'price': price,
            'amount': amount,
            'cost': cost,
            'fee': None,
        }

    async def fetch_trades(self, symbol, since=None, limit=50, params={}):
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'market': market['id'],
            'limit': limit,
        }
        response = await self.publicGetTrades(self.extend(request, params))
        return self.parse_trades(response, market, since, limit)

    def parse_ohlcv(self, ohlcv, market=None, timeframe='1m', since=None, limit=None):
        return [
            self.parse8601(self.safe_string(ohlcv, 'timestamp')),
            self.safe_float(ohlcv, 'open'),
            self.safe_float(ohlcv, 'high'),
            self.safe_float(ohlcv, 'low'),
            self.safe_float(ohlcv, 'close'),
            self.safe_float(ohlcv, 'volume'),
        ]

    async def fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'market': market['id'],
            'period': self.timeframes[timeframe],
        }
        if since is not None:
            request['timestamp'] = since
        response = await self.publicGetOhlc(self.extend(request, params))
        return self.parse_ohlcvs(response, market, timeframe, since, limit)

    async def fetch_balance(self, params={}):
        await self.load_markets()
        response = await self.privateGetBalances(params)
        result = {'info': response}
        for i in range(0, len(response)):
            balance = response[i]
            currency = balance['currency'].upper()
            if currency in self.currencies_by_id:
                currency = self.currencies_by_id[currency]['code']
            account = {
                'free': balance['available'],
                'used': balance['locked'],
                'total': balance['total'],
            }
            result[currency] = account
        return self.parse_balance(result)

    def parse_order_status(self, status):
        statuses = {
            'filled': 'closed',
            'rejected': 'closed',
            'partially_filled': 'open',
            'pending_cancellation': 'open',
            'pending_modification': 'open',
            'open': 'open',
            'new': 'open',
            'queued': 'open',
            'cancelled': 'canceled',
            'triggered': 'triggered',
        }
        return self.safe_string(statuses, status, status)

    def parse_order(self, order, market=None):
        id = self.safe_string(order, 'id')
        symbol = None
        marketId = self.safe_string(order, 'market')
        market = self.safe_value(self.markets_by_id, marketId, market)
        if market is not None:
            symbol = market['symbol']
        price = self.safe_float(order, 'price')
        average = self.safe_float(order, 'averagePrice')
        amount = self.safe_float(order, 'volume')
        filled = self.safe_float(order, 'executedVolume')
        remaining = self.safe_float(order, 'remainingVolume')
        cost = None
        if average is not None:
            if filled is not None:
                cost = average * filled
            else:
                cost = average * amount
        status = self.parse_order_status(self.safe_string(order, 'state'))
        side = self.safe_string(order, 'side')
        if side == 'bid':
            side = 'buy'
        elif side == 'ask':
            side = 'sell'
        type = self.safe_string(order, 'orderType')
        timestamp = self.parse8601(self.safe_string(order, 'createdAt'))
        trades = None  # not to be confused with trades count
        return {
            'id': id,
            'datetime': self.iso8601(timestamp),
            'timestamp': timestamp,
            'lastTradeTimestamp': None,
            'status': status,
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'cost': cost,
            'average': average,
            'amount': amount,
            'filled': filled,
            'trades': trades,
            'remaining': remaining,
            'fee': None,
            'info': order,
        }

    async def create_order(self, symbol, type, side, amount, price=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        method = 'privatePostOrders'
        order = {
            'side': side,
            'volume': amount,
        }
        if type is not None:
            order['orderType'] = type
        if price is not None:
            order['price'] = price
        request = {
            'market': market['id'],
            'orders': [order],
        }
        response = await getattr(self, method)(self.extend(request, params))
        return self.parse_order(response[0], market)

    async def cancel_order(self, id, symbol=None, params={}):
        await self.load_markets()
        response = await self.privateDeleteOrdersId(self.extend({
            'id': id,
        }, params))
        return self.parse_order(self.extend(response, {'id': id}))

    async def cancel_orders(self, side=None, params={}):
        await self.load_markets()
        request = {}
        if side is not None:
            request['side'] = side
        response = await self.privateDeleteOrders(self.extend(request, params))
        return self.parse_orders(response)

    async def fetch_order(self, id, symbol=None, params={}):
        await self.load_markets()
        request = {
            'id': id,
        }
        response = await self.privateGetOrdersId(self.extend(request, params))
        return self.parse_order(response)

    async def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'market': market['id'],
        }
        if limit is not None:
            request['limit'] = limit
        result = await self.privateGetOrders(self.extend(request, params))
        return self.parse_orders(result, None, since, limit)

    async def fetch_deposits(self, code=None, since=None, limit=None, params={}):
        await self.load_markets()
        if code is None:
            raise ExchangeError(self.id + ' fetchDeposits() requires a currency code arguemnt')
        currency = self.currency(code)
        request = {
            'currency': currency['id'],
        }
        response = await self.privateGetDepositsCrypto(self.extend(request, params))
        deposits = []
        for i in range(0, len(response)):
            deposits.append(response[i])
        return self.parseTransactions(deposits, currency)

    def parse_transaction_status(self, status):
        statuses = {
            'processing': 'pending',
            'rejected': 'failed',
            'accepted': 'ok',
            'succeed': 'ok',
        }
        return statuses[status] if (status in list(statuses.keys())) else status

    async def fetch_my_trades(self, symbol=None, since=None, limit=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'market': market['id'],
        }
        if limit is not None:
            request['limit'] = limit
        response = await self.privateGetTradesMy(self.extend(request, params))
        return self.parse_trades(response, market, since, limit)

    async def fetch_withdrawals(self, code=None, since=None, limit=None, params={}):
        await self.load_markets()
        currency = self.currency(code)
        request = {
            'currency': currency['id'],
        }
        if limit is not None:
            request['limit'] = limit
        currencyCode = currency['code']
        isFiat = False
        for i in range(0, len(self.supportedFiat)):
            if currencyCode == self.supportedFiat[i]:
                isFiat = True
        method = 'privateGetWithdrawsFiat' if isFiat else 'privateGetWithdrawsCrypto'
        response = await getattr(self, method)(self.extend(request, params))
        withdrawals = []
        for i in range(0, len(response)):
            withdrawals.append(response[i])
        return self.parseTransactions(withdrawals, currency, since, limit)

    def parse_transaction_statuses(self, status):
        statuses = {
        }
        return self.safe_string(statuses, status, status)

    def parse_transaction(self, transaction, currency=None):
        id = self.safe_string(transaction, 'id')
        txid = self.safe_string(transaction, 'txid')
        timestamp = self.parse8601(self.safe_string(transaction, 'createdAt'))
        code = None
        currencyId = self.safe_string(transaction, 'currency')
        address = self.safe_string(transaction, 'address')
        currency = self.safe_value(self.currencies_by_id, currencyId)
        if currency is not None:
            code = currency['code']
        else:
            code = self.common_currency_code(currencyId)
        amount = self.safe_float(transaction, 'amount')
        status = self.parse_transaction_status(self.safe_string(transaction, 'state'))
        updated = self.safe_string(transaction, 'createdAt')
        type = self.safe_string(transaction, 'type')
        fee = {
            'cost': self.safe_float(transaction, 'fee'),
            'currency': code,
            'rate': None,
        }
        return {
            'info': transaction,
            'id': id,
            'txid': txid,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'address': address,
            'tag': None,  # or is it defined?
            'type': type,  # direction of the transaction,('deposit' | 'withdraw')
            'amount': amount,
            'currency': code,
            'status': status,
            'updated': updated,
            'fee': fee,
        }

    def sign(self, path, api='public', method='GET', params=None, headers=None, body=None):
        url = self.urls['api'] + '/' + self.implode_params(path, params)
        query = None
        if method == 'GET':
            query = self.omit(params, self.extract_params(path))
            query = self.urlencode(query)
            if len(query):
                url += '?' + query
        elif method != 'DELETE':
            body = params
        headers = {'Content-Type': 'application/json'}
        if api == 'private':
            self.check_required_credentials()
            nonce = self.nonce()
            nonce = str(nonce)
            encodedApiKey = self.encode(self.apiKey)
            encodedNonce = self.encode(nonce)
            rawSignature = base64.b64encode(encodedApiKey) + base64.b64encode(encodedNonce)
            stringifyedPayload = ''
            if body and body > 0:
                stringifyedPayload = self.encode(json.dumps(body))
            body = json.dumps(body)
            rawSignature = rawSignature + base64.b64encode(stringifyedPayload)
            encodedSecret = self.encode(self.secret)
            signature = self.hmac(rawSignature, encodedSecret, hashlib.sha384, 'base64')
            headers['X-Blockbid-Signature'] = signature
            headers['X-Blockbid-Nonce'] = nonce
            headers['X-Blockbid-Api-Key'] = self.apiKey
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_errors(self, code, reason, url, method, headers, body, response, request_headers, request_body):
        if not self.is_json_encoded_object(body):
            return  # fallback to default error handler
        realResponse = json.loads(body)
        error = self.safe_value(realResponse, 'error')
        if error is not None:
            feedback = self.id + ' ' + body + request_body
            code = self.safe_string(error, 'name')
            exact = self.exceptions['exact']
            if code in exact:
                raise exact[code](feedback)
            raise ExchangeError(feedback)  # unknown message

    def nonce(self):
        return self.milliseconds()
